import FizzBuzzFibonacciOpenRules from "../../../benchmarking/pt/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenOutput from "../fizz-buzz-fibonacci-open-output.mdx";
import FizzBuzzFibonacciOpenOutputDefault from "../fizz-buzz-fibonacci-open-output-default.mdx";

## Expandir FizzBuzzFibonacci em C++

Nosso jogo √© um sucesso! As crian√ßas realmente adoram jogar FizzBuzzFibonacci.
Tanto que nossos executivos decidiram que querem uma sequ√™ncia.
Mas este √© o mundo moderno, precisamos de Receita Recorrente Anual (ARR) e n√£o de compras √∫nicas!
A nova vis√£o para o nosso jogo √© que ele seja infinito, sem mais viver entre os limites de `1` e `100` (mesmo que sejam inclusivos).
N√£o, estamos indo para novas fronteiras!

<FizzBuzzFibonacciOpenRules />

Para que nosso jogo funcione para qualquer n√∫mero, precisaremos aceitar um argumento de linha de comando.
Atualize a fun√ß√£o `main` para ficar assim:

{ props.children }

- Atualize a fun√ß√£o `main` para aceitar `argc` e `argv`.
- Pegue o primeiro argumento passado para nosso jogo e verifique se √© um d√≠gito.
  - Se for, analise o primeiro argumento como um inteiro, `i`.
  - Jogue nosso jogo com o inteiro rec√©m-analisado `i`.
- Se a an√°lise falhar ou nenhum argumento for passado, padr√£o √© solicitar uma entrada v√°lida.

Agora podemos jogar nosso jogo com qualquer n√∫mero!
Recomplie nosso execut√°vel `game` e depois
execute o execut√°vel seguido de um inteiro para jogar nosso jogo:

<FizzBuzzFibonacciOpenOutput />

E se omitirmos ou fornecermos um n√∫mero inv√°lido:

<FizzBuzzFibonacciOpenOutputDefault />

Uau, esse foi um teste completo! CI aprovado. Nossos chefes est√£o emocionados.
Vamos lan√ßar! üöÄ