import FizzBuzzFibonacciOpenRules from "../../../benchmarking/fr/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenOutput from "../fizz-buzz-fibonacci-open-output.mdx";
import FizzBuzzFibonacciOpenOutputDefault from "../fizz-buzz-fibonacci-open-output-default.mdx";

## √âtendre FizzBuzzFibonacci en C++

Notre jeu est un succ√®s ! Les enfants adorent effectivement jouer √† FizzBuzzFibonacci.
√Ä tel point que la direction a entendu parler de cela et souhaite une suite.
Mais c'est le monde moderne, nous avons besoin de revenus r√©currents annuels (ARR) et non d'achats uniques !
La nouvelle vision pour notre jeu est qu'il soit ouvert, plus de limites entre `1` et `100` (m√™me si elles sont inclusives).
Non, nous explorons de nouveaux horizons !

<FizzBuzzFibonacciOpenRules />

Pour que notre jeu fonctionne avec n'importe quel nombre, nous devrons accepter un argument en ligne de commande.
Mettez √† jour la fonction `main` pour qu'elle ressemble √† ceci :

{ props.children }

- Mettez √† jour la fonction `main` pour prendre en compte `argc` et `argv`.
- Obtenez le premier argument pass√© √† notre jeu et v√©rifiez s'il s'agit d'un chiffre.
  - Si c'est le cas, analysez le premier argument comme un entier, `i`.
  - Jouez √† notre jeu avec l'entier `i` nouvellement analys√©.
- Si l'analyse √©choue ou qu'aucun argument n'est pass√©, passez par d√©faut √† une demande d'entr√©e valide.

Maintenant, nous pouvons jouer √† notre jeu avec n'importe quel nombre !
Recompilez notre ex√©cutable `game` puis
ex√©cutez l'ex√©cutable suivi d'un entier pour jouer √† notre jeu :

<FizzBuzzFibonacciOpenOutput />

Et si nous omettons ou fournissons un nombre invalide :

<FizzBuzzFibonacciOpenOutputDefault />

Wow, ce fut un test exhaustif ! L'int√©gration continue passe avec succ√®s. Nos patrons sont ravis.
Exp√©dions-le ! üöÄ