import FizzBuzzFibonacciOpenRules from "../../../benchmarking/es/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenOutput from "../fizz-buzz-fibonacci-open-output.mdx";
import FizzBuzzFibonacciOpenOutputDefault from "../fizz-buzz-fibonacci-open-output-default.mdx";

## Expandir FizzBuzzFibonacci en C++

¬°Nuestro juego es un √©xito! A los ni√±os realmente les encanta jugar a FizzBuzzFibonacci.
¬°Tanto que ha llegado la noticia de que los ejecutivos quieren una secuela!
¬°Pero este es el mundo moderno, necesitamos Ingresos Recurrentes Anuales (ARR) no compras √∫nicas!
La nueva visi√≥n para nuestro juego es que sea abierto, ya no m√°s viviendo entre los l√≠mites de `1` y `100` (incluso si son inclusivos).
¬°No, estamos en nuevos horizontes!

<FizzBuzzFibonacciOpenRules />

Para que nuestro juego funcione con cualquier n√∫mero, necesitaremos aceptar un argumento desde la l√≠nea de comandos.
Actualice la funci√≥n `main` para que se vea as√≠:

{ props.children }

- Actualice la funci√≥n `main` para tomar `argc` y `argv`.
- Obtenga el primer argumento pasado a nuestro juego y verifique si es un d√≠gito.
  - Si es as√≠, analice el primer argumento como un entero, `i`.
  - Juegue nuestro juego con el nuevo entero analizado `i`.
- Si la conversi√≥n falla o no se pasa ning√∫n argumento, por defecto solicitar una entrada v√°lida.

¬°Ahora podemos jugar nuestro juego con cualquier n√∫mero!
Recompile nuestro ejecutable `game` y
ejecute el ejecutable seguido de un entero para jugar nuestro juego:

<FizzBuzzFibonacciOpenOutput />

Y si omitimos o proporcionamos un n√∫mero inv√°lido:

<FizzBuzzFibonacciOpenOutputDefault />

¬°Vaya, eso fue una prueba exhaustiva! La integraci√≥n continua pasa. Nuestros jefes est√°n encantados.
¬°Vamos a lanzarlo! üöÄ