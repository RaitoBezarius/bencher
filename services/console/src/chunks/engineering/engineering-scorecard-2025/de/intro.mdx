Beim Entwickeln einer neuen Technologie, wie [Bencher][bencher],
besteht ein grundlegender Konflikt zwischen dem Wunsch, [langweilige Technologie zu wählen][choose boring technology]
und dem, die [Durchschnitte zu übertreffen][beating the averages].
Im Moment kann es schwierig sein, genau zu erkennen, wo man in diesem Tauziehen steht.
Alle drei Jahre bringt die Programmiersprache Rust eine neue [Rust-Edition][rust editions] heraus.
Ich denke, das ist ein schönes Tempo.
Es ist lange genug, um wirkliche Fortschritte zu erzielen.
Doch kurz genug, um nicht zu weit abzuschweifen.
Da Bencher in diesem Frühjahr 3 Jahre alt wird,
dachte ich, es wäre eine großartige Zeit, innezuhalten und über alle Ingenieursentscheidungen nachzudenken, die uns hierher gebracht haben.

In diesem Beitrag werde ich darauf zurückblicken, wo Bencher seine "Innovationstokens" in den letzten drei Jahren eingesetzt hat.
Bencher ist eine [Open Source][github bencher] Suite von [kontinuierlichen Benchmark-Tools][continuous benchmarking].
Ich beginne beim Frontend der [Bencher-Architektur][architecture] und bewege mich den gesamten Stack hinunter.
An jedem Punkt entlang des Weges werde ich diskutieren, wie wir hierher gekommen sind
und ein binäres Urteil darüber fällen, wie sich jede Ingenieursentscheidung ausgezahlt hat.

[bencher]: https://bencher.dev
[choose boring technology]: https://mcfunley.com/choose-boring-technology
[beating the averages]: https://paulgraham.com/avg.html
[rust editions]: https://doc.rust-lang.org/edition-guide/editions/
[github bencher]: https://github.com/bencherdev/bencher
[continuous benchmarking]: /de/docs/explanation/continuous-benchmarking/
[architecture]: /de/docs/reference/architecture/