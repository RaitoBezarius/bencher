import FizzBuzzFibonacciOpenRules from "../../benchmarking/en/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenOutput from "../fizz-buzz-fibonacci-open-output.mdx";
import FizzBuzzFibonacciOpenOutputDefault from "../fizz-buzz-fibonacci-open-output-default.mdx";

## Expandir FizzBuzzFibonacci en Python

¬°Nuestro juego es un √©xito! De verdad, a los ni√±os les encanta jugar FizzBuzzFibonacci.
¬°Tanto que ha llegado la noticia de los ejecutivos de que quieren una secuela!
Pero este es el mundo moderno, ¬°necesitamos ingresos recurrentes anuales (ARR) y no compras √∫nicas!
La nueva visi√≥n para nuestro juego es que sea abierto, ya no vivir entre los l√≠mites de `1` y `100` (incluso si es inclusivo).
¬°No, vamos hacia nuevas fronteras!

<FizzBuzzFibonacciOpenRules />

Para que nuestro juego funcione con cualquier n√∫mero, necesitaremos aceptar un argumento de l√≠nea de comandos.
Actualiza la ejecuci√≥n principal para que se vea as√≠:

{ props.children }

- Importar el paquete `sys`.
- Recoger todos los argumentos (`args`) pasados a nuestro juego desde la l√≠nea de comandos.
- Obtener el primer argumento pasado a nuestro juego y verificar si es un d√≠gito.
  - Si es as√≠, analiza el primer argumento como un entero, `i`.
  - Juega nuestro juego con el nuevo entero analizado `i`.
- Si el an√°lisis falla o no se pasa ning√∫n argumento, por defecto solicitar una entrada v√°lida.

¬°Ahora podemos jugar a nuestro juego con cualquier n√∫mero!
Ejecuta `python game.py` seguido de un n√∫mero entero para jugar a nuestro juego:

<FizzBuzzFibonacciOpenOutput />

Y si omitimos o proporcionamos un n√∫mero no v√°lido:

<FizzBuzzFibonacciOpenOutputDefault />

¬°Vaya, eso fue una prueba exhaustiva! La integraci√≥n continua pasa. Nuestros jefes est√°n emocionados.
¬°Envi√©moslo! üöÄ