import FizzBuzzFibonacciOpenRules from "../../benchmarking/en/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenOutput from "../fizz-buzz-fibonacci-open-output.mdx";
import FizzBuzzFibonacciOpenOutputDefault from "../fizz-buzz-fibonacci-open-output-default.mdx";

## √âtendre FizzBuzzFibonacci en Python

Notre jeu est un succ√®s ! Les enfants adorent vraiment jouer √† FizzBuzzFibonacci.
Tellement que les dirigeants ont d√©cid√© qu'ils voulaient une suite.
Mais c'est le monde moderne, nous avons besoin de revenus r√©currents annuels (ARR) et non plus d'achats uniques !
La nouvelle vision pour notre jeu est qu'il soit ouvert, termin√© de vivre entre la limite de `1` et `100` (m√™me si elle est incluse).
Non, nous explorons de nouveaux horizons !

<FizzBuzzFibonacciOpenRules />

Pour que notre jeu fonctionne pour n'importe quel nombre, nous devrons accepter un argument de la ligne de commande.
Mettez √† jour l'ex√©cution principale pour qu'elle ressemble √† ceci :

{ props.children }

- Importez le paquet `sys`.
- R√©cup√©rez tous les arguments (`args`) pass√©s √† notre jeu depuis la ligne de commande.
- Obtenez le premier argument pass√© √† notre jeu et v√©rifiez s'il s'agit d'un chiffre.
  - Si c'est le cas, analysez le premier argument en tant qu'entier, `i`.
  - Jouez √† notre jeu avec l'entier nouvellement analys√© `i`.
- Si l'analyse √©choue ou si aucun argument n'est pass√©, par d√©faut, invitez √† entrer une saisie valide.

Maintenant, nous pouvons jouer √† notre jeu avec n'importe quel nombre !
Ex√©cutez `python game.py` suivi d'un nombre entier pour jouer √† notre jeu :

<FizzBuzzFibonacciOpenOutput />

Et si nous omettons ou fournissons un nombre invalide :

<FizzBuzzFibonacciOpenOutputDefault />

Wow, cela a √©t√© un test exhaustif ! L'int√©gration continue (CI) r√©ussit. Nos patrons sont ravis.
Livrons-le ! üöÄ