import FizzBuzzFibonacciOpenRules from "../../benchmarking/pt/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenOutput from "../fizz-buzz-fibonacci-open-output.mdx";
import FizzBuzzFibonacciOpenOutputDefault from "../fizz-buzz-fibonacci-open-output-default.mdx";

## Expandir FizzBuzzFibonacci em Python

Nosso jogo √© um sucesso! As crian√ßas realmente adoram jogar FizzBuzzFibonacci. Tanto que a not√≠cia chegou aos executivos de que eles querem uma sequ√™ncia. Mas este √© o mundo moderno, precisamos de Receita Recorrente Anual (ARR) e n√£o de compras √∫nicas! A nova vis√£o para o nosso jogo √© que ele seja indefinido, n√£o mais vivendo entre o limite de `1` e `100` (mesmo que seja inclusivo). N√£o, estamos indo para novas fronteiras!

<FizzBuzzFibonacciOpenRules />

Para que nosso jogo funcione para qualquer n√∫mero, precisaremos aceitar um argumento de linha de comando. Atualize a execu√ß√£o principal para se parecer com isto:

{ props.children }

- Importe o pacote `sys`.
- Recolha todos os argumentos (`args`) passados para o nosso jogo a partir da linha de comando.
- Obtenha o primeiro argumento passado para o nosso jogo e verifique se √© um d√≠gito.
  - Se for, analise o primeiro argumento como um inteiro, `i`.
  - Jogue nosso jogo com o novo inteiro `i` analisado.
- Se a an√°lise falhar ou nenhum argumento for passado, padr√£o para solicitar uma entrada v√°lida.

Agora podemos jogar nosso jogo com qualquer n√∫mero! Execute `python game.py` seguido por um n√∫mero inteiro para jogar nosso jogo:

<FizzBuzzFibonacciOpenOutput />

E se omitirmos ou fornecermos um n√∫mero inv√°lido:

<FizzBuzzFibonacciOpenOutputDefault />

Uau, isso foi um teste completo! CI aprova. Nossos chefes est√£o encantados. Vamos lan√ßar! üöÄ