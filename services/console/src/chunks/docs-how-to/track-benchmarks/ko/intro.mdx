대부분의 벤치마크 결과는 일시적입니다.
터미널의 스크롤백 한계에 도달하면 사라집니다.
일부 벤치마크 하니스는 결과를 캐시할 수 있게 하지만, 대부분은 로컬에서만 가능합니다.
Bencher는 로컬 및 CI 실행 모두에서 벤치마크를 추적하고 결과를 비교할 수 있게 해주며,
여전히 [좋아하는 벤치마크 하니스][adapters]를 사용할 수 있습니다.

[지속적 벤치마킹][continuous benchmarking], 즉 CI에서의 벤치마킹 시 벤치마크 결과를 비교하는 세 가지 인기 있는 방법이 있습니다:

- [통계적 지속적 벤치마킹][statistical continuous benchmarking]
  1. 벤치마크 결과를 시간에 따라 추적하여 기준선 생성
  2. 이 기준선을 [통계적 기준][thresholds]과 함께 사용하여 통계적 경계선 생성
  3. 새로운 결과를 이 통계적 경계선과 비교하여 성능 퇴행 감지
- [상대적 지속적 벤치마킹][relative continuous benchmarking]
  1. 현재 기준선 코드에 대해 벤치마크 실행
  2. 코드의 새로운 버전으로 전환
  3. [백분율 기준][percentage thresholds]을 사용하여 기준선 코드의 경계 생성
  4. 코드의 새로운 버전에 대해 벤치마크 실행
  5. 코드의 새로운 버전 결과를 기준선 코드 결과와 비교하여 성능 퇴행 감지
- [변화점 탐지][change point detection]
  1. 가끔 코드의 새로운 버전에 대해 벤치마크 실행
  2. 변화점 탐지 알고리즘을 사용하여 성능 퇴행 감지
  3. 성능 퇴행을 유발한 커밋 찾기 위해 이분법적 분석 수행

[adapters]: /ko/docs/explanation/adapters/
[continuous benchmarking]: /ko/docs/explanation/continuous-benchmarking/
[thresholds]: /ko/docs/explanation/thresholds/
[percentage thresholds]: /ko/docs/explanation/thresholds/#percentage-thresholds

[statistical continuous benchmarking]: #statistical-continuous-benchmarking
[relative continuous benchmarking]: #relative-continuous-benchmarking
[change point detection]: #change-point-detection