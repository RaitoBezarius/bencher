## Обнаружение точек изменений

Обнаружение точек изменений использует [алгоритм обнаружения изменений][change detection] для оценки большого окна недавних результатов.
Это позволяет алгоритму игнорировать выбросы как шум и снижать количество ложноположительных срабатываний.
Хотя обнаружение точек изменений считается [непрерывным сравнительным анализом][continuous benchmarking],
оно не позволяет обнаруживать регрессии производительности в CI.
То есть, вы не можете обнаружить регрессию производительности до слияния ветки функции.
Это иногда называют "внесистемным" обнаружением.

Например, если у вас есть тест `bench_my_critical_path`,
и у него были следующие исторические задержки: `5 ms`, `6 ms`, `5 ms`, `5ms`, `7ms`.

Если следующий результат теста составил `11 ms`, то порог статистического непрерывного сравнительного анализа
и алгоритм обнаружения точек изменений интерпретировали бы это по-разному.
Порог, вероятно, был бы превышен, и было бы сгенерировано предупреждение.
Если этот прогон теста был связан с pull-запросом,
сборка, вероятно, была бы помечена как неудачная из-за этого предупреждения.
Однако, алгоритм точек изменений не сделал бы ничего... пока.
Если бы в следующий прогон результаты вернулись к `5 ms`, то, вероятно, предупреждение не было бы сгенерировано.
Наоборот, если бы один-два следующих прогона дали результаты `10 ms` и `12 ms`,
только тогда алгоритм точек изменений сгенерировал бы предупреждение.

Заинтересованы в использовании обнаружения точек изменений с Bencher?
Если да, оставьте комментарий по [трековому вопросу][github issue 365]
или [свяжитесь с нами напрямую][help].

[change detection]: https://en.wikipedia.org/wiki/Change_detection
[github issue 365]: https://github.com/bencherdev/bencher/issues/365

[continuous benchmarking]: /ru/docs/explanation/continuous-benchmarking/
[help]: /help/