import PlayGameRsBenchPlayGame from "../play-game-rs-bench-play-game.mdx";

### Erstellen Sie eine Benchmark-Funktion

Nun k√∂nnen wir eine Benchmark-Funktion erstellen, die das FizzBuzzFibonacci-Spiel spielt:

<PlayGameRsBenchPlayGame />

Zeile f√ºr Zeile:
- Erstellen Sie eine Benchmark-Funktion, die der Signatur in `CustomBenchmark` entspricht.
- Erstellen Sie einen `dhat::Profiler` im Testmodus, um Ergebnisse von unserem `dhat::Alloc` benutzerdefinierten, globalen Speicherzuteiler zu sammeln.
- F√ºhren Sie unsere `play_game` Funktion in einer ‚Äûblack box‚Äú aus, damit der Compiler unseren Code nicht optimiert.
- Iterieren Sie von `1` bis `100` inklusive.
- Rufen Sie f√ºr jede Zahl `play_game` auf, wobei `print` auf `false` gesetzt ist.
- Geben Sie unsere Speicherbelegungsstatistiken als `dhat::HeapStats` zur√ºck.

> üê∞ Wir setzen `print` auf `false` f√ºr die `play_game` Funktion.
> Dies verhindert, dass `play_game` auf Standardausgabe druckt.
> Das Parameterisieren Ihrer Bibliotheksfunktionen auf diese Weise
> kann sie besser f√ºr Benchmarking geeignet machen.
> Allerdings bedeutet dies, dass wir die Bibliothek m√∂glicherweise
> nicht genau so benchmarken wie sie in der Produktion verwendet wird.
>
> In diesem Fall m√ºssen wir uns fragen:
> 1. Sind die Ressourcen, die zum Drucken auf Standardausgabe ben√∂tigt werden, f√ºr uns relevant?
> 2. Ist das Drucken auf Standardausgabe eine m√∂gliche Rauschquelle?
>
> F√ºr unser Beispiel haben wir folgende Antworten gew√§hlt:
> 1. Nein, uns ist das Drucken auf Standardausgabe nicht wichtig.
> 2. Ja, es ist sehr wahrscheinlich eine Rauschquelle.
>
> Daher haben wir das Drucken auf Standardausgabe als Teil dieses Benchmarks weggelassen.
> Benchmarking ist schwierig, und oft gibt es nicht die eine richtige Antwort auf solche Fragen.
> [Es kommt darauf an][changelog it depends].

[changelog it depends]: https://changelog.com/topic/itdepends
