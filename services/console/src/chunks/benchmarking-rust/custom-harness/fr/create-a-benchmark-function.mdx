import PlayGameRsBenchPlayGame from "../play-game-rs-bench-play-game.mdx";

### Cr√©er une Fonction de Benchmark

Maintenant, nous pouvons cr√©er une fonction de benchmark qui joue au jeu FizzBuzzFibonacci :

<PlayGameRsBenchPlayGame />

Ligne par ligne :
- Cr√©er une fonction de benchmark qui correspond √† la signature utilis√©e dans `CustomBenchmark`.
- Cr√©er un `dhat::Profiler` en mode test,
  pour collecter les r√©sultats de notre `dhat::Alloc` personnalis√©, allocateur global.
- Ex√©cuter notre fonction `play_game` √† l'int√©rieur d'une ¬´ bo√Æte noire ¬ª afin que le compilateur n'optimise pas notre code.
- It√©rer de `1` √† `100` inclusivement.
- Pour chaque nombre, appeler `play_game`, avec `print` d√©fini sur `false`.
- Retourner nos statistiques d'allocation sur le tas comme `dhat::HeapStats`.

> üê∞ Nous avons d√©fini `print` sur `false` pour la fonction `play_game`.
> Cela emp√™che `play_game` d'afficher des informations sur la sortie standard.
> Param√©trer vos fonctions de biblioth√®que de cette mani√®re
> peut les rendre plus adapt√©es au benchmarking.
> Cependant, cela signifie aussi que nous ne benchmarkons peut-√™tre pas la biblioth√®que 
> exactement comme elle est utilis√©e en production.
>
> Dans ce cas, nous devons nous demander :
> 1. Les ressources n√©cessaires pour afficher sur la sortie standard sont-elles importants pour nous ?
> 2. L'affichage sur la sortie standard est-il une source potentielle de bruit ?
>
> Pour notre exemple, nous avons conclu :
> 1. Non, afficher sur la sortie standard n'est pas important pour nous.
> 2. Oui, c'est une source de bruit tr√®s probable.
>
> Par cons√©quent, nous avons omis l'affichage sur la sortie standard dans ce benchmark.
> Le benchmarking est difficile, et il n'y a souvent pas de r√©ponse unique √† des questions comme celles-ci.
> [√áa d√©pend][changelog it depends].

[changelog it depends]: https://changelog.com/topic/itdepends
