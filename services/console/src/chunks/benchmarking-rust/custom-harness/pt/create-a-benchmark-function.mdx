import PlayGameRsBenchPlayGame from "../play-game-rs-bench-play-game.mdx";

### Crie uma Fun√ß√£o de Benchmark

Agora, podemos criar uma fun√ß√£o de benchmark que joga o jogo FizzBuzzFibonacci:

<PlayGameRsBenchPlayGame />

Linha por linha:
- Crie uma fun√ß√£o de benchmark que corresponda √† assinatura usada em `CustomBenchmark`.
- Crie um `dhat::Profiler` em modo de teste,
  para coletar resultados do nosso alocador global personalizado `dhat::Alloc`.
- Execute nossa fun√ß√£o `play_game` dentro de uma "caixa preta" para que o compilador n√£o otimize nosso c√≥digo.
- Itere de `1` a `100`, inclusivamente.
- Para cada n√∫mero, chame `play_game`, com `print` definido como `false`.
- Retorne nossas estat√≠sticas de aloca√ß√£o de heap como `dhat::HeapStats`.

> üê∞ Definimos `print` como `false` para a fun√ß√£o `play_game`.
> Isso impede que `play_game` imprima no padr√£o de sa√≠da.
> Parametrizar suas fun√ß√µes de biblioteca desta maneira
> pode torn√°-las mais adequadas para benchmark.
> No entanto, isso significa que talvez n√£o estejamos fazendo benchmark da biblioteca
> exatamente da mesma maneira que ela √© usada em produ√ß√£o.
>
> Neste caso, temos que nos perguntar:
> 1. Nos importamos com os recursos necess√°rios para imprimir no padr√£o de sa√≠da?
> 2. Imprimir no padr√£o de sa√≠da √© uma poss√≠vel fonte de ru√≠do?
>
> Para nosso exemplo, optamos por:
> 1. N√£o, n√£o nos importamos com a impress√£o no padr√£o de sa√≠da.
> 2. Sim, √© uma fonte muito prov√°vel de ru√≠do.
>
> Portanto, omitimos a impress√£o no padr√£o de sa√≠da como parte deste benchmark.
> Fazer benchmark √© dif√≠cil, e muitas vezes n√£o h√° uma resposta certa para perguntas como essas.
> [Depende][changelog it depends].

[changelog it depends]: https://changelog.com/topic/itdepends