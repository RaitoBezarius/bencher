import FizzBuzzFibonacciOpenRules from "../../benchmarking/es/fizz-buzz-fibonacci-open-rules.mdx";
import FizzBuzzFibonacciOpenRustOutput from "../fizz-buzz-fibonacci-open-rust-output.mdx";
import FizzBuzzFibonacciOpenRustOutputDefault from "../fizz-buzz-fibonacci-open-rust-output-default.mdx";

## Expande FizzBuzzFibonacci en Rust

¬°Nuestro juego es todo un √©xito! A los ni√±os definitivamente les encanta jugar FizzBuzzFibonacci.
Tanto as√≠ que lleg√≥ la noticia de los ejecutivos de que quieren una secuela.
Pero este es el mundo moderno, ¬°necesitamos ingresos recurrentes anuales (ARR) no compras √∫nicas!
La nueva visi√≥n para nuestro juego es que sea abierto, ¬°no m√°s limitaciones entre el `1` y el `100` (aunque sea inclusivo)!
¬°No, vamos hacia nuevas fronteras!

<FizzBuzzFibonacciOpenRules />

Para que nuestro juego funcione con cualquier n√∫mero, necesitaremos aceptar un argumento de l√≠nea de comandos.
Actualiza la funci√≥n `main` para que se vea as√≠:

{ props.children }

- Recolecta todos los argumentos (`args`) pasados a nuestro juego desde la l√≠nea de comandos.
- Obt√©n el primer argumento pasando a nuestro juego y anal√≠zalo como un entero sin signo `i`.
- Si el an√°lisis falla o no se pasa ning√∫n argumento, por defecto, nuestro juego tomar√° el `15` como entrada.
- Finalmente, juega nuestro juego con el nuevo entero sin signo `i`.

¬°Ahora podemos jugar nuestro juego con cualquier n√∫mero!
Usa `cargo run` seguido de `--` para pasar argumentos a nuestro juego:

<FizzBuzzFibonacciOpenRustOutput />

Y si omitimos o proporcionamos un n√∫mero inv√°lido:

<FizzBuzzFibonacciOpenRustOutputDefault />

Vaya, ¬°eso fue una prueba exhaustiva! CI pasa. Nuestros jefes est√°n emocionados.
¬°Vamos a lanzarlo! üöÄ