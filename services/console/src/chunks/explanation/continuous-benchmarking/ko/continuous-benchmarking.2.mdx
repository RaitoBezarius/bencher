import BencherFooter from "../../../learn/ko/bencher-footer.mdx";

<BencherFooter />

## 지속적인 벤치마킹 vs 로컬 벤치마크 비교

여러 벤치마크 하네스들이 로컬에서 결과를 비교할 수 있게 해줍니다.
로컬 비교는 성능을 튜닝하면서 빠르게 반복할 때 매우 훌륭합니다.
그러나, 이는 지속적으로 성능 회귀를 찾아내는데 의존하는 것이 아니어야 합니다.
단위 테스트를 로컬에서 실행할 수 있다고 해서 CI가 필요 없는 것처럼,
벤치마크를 로컬에서 실행하고 비교할 수 있다고 해서 CB가 필요 없는 것은 아닙니다.

로컬 벤치마크 비교 도구들이 제공하지 못하는 여러 기능들이 Bencher에는 있습니다:
- 다른 테스트베드들 사이에서 같은 벤치마크 비교
- 언어와 하네스들을 걸쳐 벤치마크 비교
- 벤치마크 결과의 협업과 공유
- 노이즈를 최소화하기 위한 전용 테스트베드에서 벤치마크 실행
- 더 이상 복사 붙여넣기 없음

## 지속적인 벤치마킹 vs 애플리케이션 성능 관리 (APM)

애플리케이션 성능 관리(APM)은 현대 소프트웨어 서비스에 필수적인 도구입니다.
그러나, APM는 제품 환경에서 사용할 수 있게 설계되었습니다.
성능 회귀가 감지되는 시점에는 이미 고객에게 영향을 미치고 있습니다.

> 대부분의 결함은 그것들을 방지하는데 드는 비용보다 더 많은 비용을 청구하게 됩니다.
> 결함이 발생할 때 결함을 수정하는 직접적인 비용과
> 손상된 관계, 잃어버린 사업, 그리고 낭비된 개발 시간 때문에 발생하는 간접적인 비용들이 많습니다.
>
> — 켄트 벡, 익스트림 프로그래밍 설명

APM 도구들이 제공하지 못하는 여러 기능들이 Bencher에는 있습니다:
- 성능 회귀를 _생산환경으로 넘어가기 전에_ 탐지하고 방지
- 코드 리뷰에 포함된 성능 변화와 영향
- 생산 환경에서의 오버헤드 없음
- 온-프레미스 배포에 효과적
- 생산 소스 코드 변경 없음

## 지속적인 벤치마킹 vs 관측 가능성

다른 이름으로 불리는 장미라고 해도 그 향은 달라지지 않을 것입니다.
위의 지속적인 벤치마킹 vs 애플리케이션 성능 관리를 참고하세요.

## 지속적인 벤치마킹 vs 지속적인 통합 (CI)

지속적인 벤치마킹(CB)은 지속적인 통합(CI)과 보완적입니다.
모든 코드 변경에 대해 CI에서 단위 테스트를 실행하는 것처럼,
모든 코드 변경에 대해 CB에서 성능 테스트를 실행해야 합니다.

> 단위 테스트와 수용 테스트는 표준 개발 프렉티스로 널리 받아들여졌지만,
> 이 트렌드는 성능 테스팅 분야로는 이어지지 않았습니다.
> 현재 흔히 사용되는 도구들은 테스터들을 일회용 코드 작성과 클릭-스크립트 방식으로 유도합니다.
> 성능 테스팅을 일류 시민으로 대우함으로써 더 많은 기능을 커버하는 더 나은 테스팅의 제작이 가능해지게 하고,
> 성능 테스팅을 생성하고 실행하는 더 나은 도구를 만들게 하며,
> 유지보수 가능하고 테스트할 수 있는 테스트 세트를 만들게 합니다.
>
> — [Thoughworks Technology Radar, 2013년 5월 22일](https://www.thoughtworks.com/en-us/radar/techniques/performance-testing-as-a-first-class-citizen)


## 지속적인 벤치마킹 vs 지속적인 부하 테스팅

지속적인 벤치마킹과 지속적인 부하 테스팅 사이의 차이를 이해하려면,
[벤치마킹](https://ko.wikipedia.org/wiki/%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC_(%EC%BB%B4%ED%93%A8%ED%8C%85))과
[부하 테스팅](https://en.wikipedia.org/wiki/Software_load_testing) 사이의 차이를 이해해야 합니다.

| 테스트 종류 |  테스트 범위  | 테스트 사용자  |
| :---------: | :-----------: | :------------: |
|  벤치마킹   | 함수 - 서비스 | 하나 - 여러 개 |
| 부하 테스팅 |    서비스     |      많음      |

벤치마킹은 함수 수준(마이크로 벤치마크)부터 서비스 수준(매크로 벤치마크)까지 소프트웨어의 성능을 테스트할 수 있습니다.
벤치마크는 당신의 코드의 특정 부분의 성능을 고립시킨 상태에서 테스트하는 데 좋습니다.
부하 테스팅은 서비스 수준에서만 소프트웨어의 성능을 테스트하고 여러 동시 사용자를 모방합니다.
부하 테스팅은 특정 부하 하에서 전체 서비스의 성능을 테스트하는 데 좋습니다.

🍦 우리가 아이스크림 트럭의 성능을 추적하고 싶다고 가정해 보세요.
벤치마킹은 아이스크림 콘을 스쿱하는 데 걸리는 시간(마이크로 벤치마크), 그리고
한 고객이 주문하고, 아이스크림을 받고, 결제하는 데 걸리는 시간(매크로 벤치마크)을 측정하는 데 사용될 수 있습니다.
부하 테스팅은 더운 여름날에 100명의 고객을 어떻게 서비스하는지를 보는 데 사용될 수 있습니다.

<br/>
<br/>

<h2><a href="/ko/docs/tutorial/quick-start/">계속 진행: 쿽스타트 ➡</a></h2>