---
title: "Engineering Review 2025"
description: "A retrospective look at how Bencher has spent its innovation tokens"
heading: "Engineering Review: 2025 Edition"
published: "2025-01-25T16:30:00Z"
modified: "2025-01-25T16:30:00Z"
sortOrder: -2025.0125
draft: true
---

When developing a new technology, like [Bencher][bencher],
there is a fundamental tension between wanting to [choose boring technology][choose boring technology]
and [beating the averages][beating the averages].
In the moment, it can be difficult to tell exactly where one stands in this tug-of-war.
Every three years, the Rust programming language comes out with a new [Rust edition][rust editions].
I think this is a nice cadence. It's long enough for real progress to be made.
Yet, short enough not to drift too far afield.
With Bencher turning 3 years old this spring,
I thought it would be a great time to stop and reflect on all the engineering decisions that got us here.

In this post, I'm going to review where Bencher has spent its "innovation tokens" over the past three years.
I'll start at the frontend of the [Bencher architecture][architecture] and move all the way down the stack.
At each stop along with way, I'll discuss how we got here and rate how each engineering decision panned out.

[bencher]: https://bencher.dev
[choose boring technology]: https://mcfunley.com/choose-boring-technology
[beating the averages]: https://paulgraham.com/avg.html
[rust editions]: https://doc.rust-lang.org/edition-guide/editions/
[architecture]: /docs/reference/architecture/

## Frontend

### Frontend Library

As a recovering C++ developer, I'm a pretty big fan of Rust.
If I had my druthers, I would have been able to write Bencher in full-stack Rust.
Dig back into the deep recesses of the [Bencher repo][bencher github],
you'll see me trying to do exactly that.
I experimented with [Yew][yew github], [Seed][seed github], and [Sycamore][sycamore github].
While they may work great for some projects,
there was one major sticking point I just couldn't get over: [JavaScript Interoperation][js ffi].

While JS interop is possible from WASM via Rust,
it was not going to be easy.
I knew I wanted Bencher to have highly interactive plots.
This meant using a library like [D3][d3 github],
which meant JS interop.

So if I was going to have to use JavaScript, which framework should I choose?

Going back to those Rust crates I experimented with,
Yew is the Rust analogue to [React Hooks][react hooks].
I'd built and deployed a frontend using React Hooks in the past,
so I knew the most about this framework.
However, I found the React Hooks lifecycle very complicated
and full of gotcha, weird edge cases.

I really liked the core principals of [functional reactive programming][functional reactive programming] (FRP) though.
This lead me to trying out both Elm and its Rust analogue, Seed.
Unfortunately, using Elm suffers from the same issues as using Rust.
Elm requires its own [JavaScript Interop][elm js interop].
I also found [The Elm Architecture][the elm architecture] a bit too restrictive for my liking.

Of all the Rust frameworks that I tried, I liked Sycamore the most.
Sycamore was inspired by [Solid][solid github].
The more that I learned about Solid, the more I liked it.
Unlike React, Solid does not use a [virtual DOM][react virtual dom].
Instead, it compiles to good ole JavaScript.
This makes it much faster, smaller, and easier to work with.
Solid is made up of just a few powerful primitives that allow for fine-grained reactivity.
When something in the UI gets updated, only the code that depends on it will rerun.
Over the past three years, I have found Solid to be a pleasure to work with.

> | Technology    | Verdict |
> | :--------:    | :-----: |
> | Rust Frontend |    ❌    |
> | SolidJS       |    ✅    |

[bencher github]: https://github.com/bencherdev/bencher
[yew github]: https://github.com/yewstack/yew
[seed github]: https://github.com/seed-rs/seed
[sycamore github]: https://github.com/sycamore-rs/sycamore
[js ffi]: https://rustwasm.github.io/docs/book/reference/js-ffi.html
[d3 github]: https://github.com/d3/d3
[react hooks]: https://react.dev/reference/react/hooks
[functional reactive programming]: https://en.wikipedia.org/wiki/Functional_reactive_programming
[elm js interop]: https://guide.elm-lang.org/interop/
[the elm architecture]: https://guide.elm-lang.org/architecture/
[solid github]: https://github.com/solidjs/solid
[react virtual dom]: https://legacy.reactjs.org/docs/faq-internals.html

### Frontend Framework

Solid itself is "just a library".
In order to build a modern frontend,
I was going to need to use a full fledged web app framework.
Wanting to keep things simple, I put all of my eggs in the Solid basket,
and I initially used [SolidStart][solid start github].
At the time, SolidStart only supported single-page apps (SPAs).

An SPA was fine for getting going.
Eventually though, I needed to start caring about things like SEO.
I was beginning to write a lot more [Bencher documentation][bencher docs].
I was also planning [the Learn section][bencher learn] of the site.
This meant that I needed both client-side rendering (CSR)
and static site generation (SSG).
SolidStart was very young, and I couldn't get it to meet all of my needs.

After learning about [Astro][astro] and trying it out,
I decided to port the entire Bencher frontend from SolidStart over to Astro.
This had a couple of drawbacks.
The most obvious was the effort involved.
Honestly, it wasn't _too_ bad.
Astro has its [islands architecture][astro islands] and
a first class [Solid integration][astro solid].
I was also able to take a lot of the logic that I need from the [Solid Router][solid router],
and it just sort of worked.

The great compromise which is still present today
is that Bencher went from a single-page app to a multi-page app.
Most places you click in the console cause a full page rerender.
Astro had the promise of [view transitions][astro view transitions],
when I first made the switch.
I tried them out, but they were buggy.
I still need to [circle back][github issue 556].

In the mean time, SolidStart seems to have caught up some.
They now support both CSR and SSG.
Though I haven't checked whether they both work on the same site like I need.
Water under the bridge.

> | Technology | Verdict |
> | :--------: | :-----: |
> | SolidStart |    ❌    |
> |   Astro    |    ✅    |

[solid start github]: https://github.com/solidjs/solid-start
[bencher docs]: /docs/
[bencher learn]: /learn/
[astro]: https://astro.build/
[astro islands]: https://docs.astro.build/en/concepts/islands/
[astro solid]: https://docs.astro.build/en/guides/integrations-guide/solid-js/
[solid router]: https://github.com/solidjs/solid-router
[astro view transitions]: https://docs.astro.build/en/guides/view-transitions/
[github issue 556]: https://github.com/bencherdev/bencher/issues/556

### Frontend Language

Astro has [built-in TypeScript support][astro typescript].
In the transition from SolidStart to Astro, I also started the transition form JavaScript to TypeScript.
Bencher's TypeScript config is set to Astro's `strictest` setting.
However, Astro does not perform type checking during builds.
As of writing, Bencher still has `604` type errors.
These type errors are used more like hints when editing code,
but they don't block the build ([yet][github issue 557]).

I also added [Typeshare][typeshare github] to sync Bencher's Rust data types with the TypeScript frontend.
This has been incredibly helpful for developing the Bencher Console.
Further, all the field validators for things like usernames, emails, etc
are shared between the Rust code and the TypeScript frontend via WASM.
It's been a bit of a hassle to get WASM working in both SolidStart and Astro.
The largest class of error that I've seen in the frontend has been places where a WASM function is called
but the WASM module hasn't loaded yet.
I've figured out how to fix it, but I'll still sometimes forget and it crops up again.

Having both the shared types and validators auto-generated from the Rust code
has made interfacing with the frontend much easier.
They both get checked in CI, so they are never out of sync.
All I have to do is make sure the HTTP requests are well formed,
and it all just works.

> | Technology | Verdict |
> | :--------: | :-----: |
> | JavaScript |    ❌    |
> | TypeScript |    ✅    |
> | Typeshare  |    ✅    |
> |   WASM     |    ✅    |

[astro typescript]: https://docs.astro.build/en/guides/typescript/
[github issue 557]: https://github.com/bencherdev/bencher/issues/557
[typeshare github]: https://github.com/1Password/typeshare

### Frontend Hosting

My initial decision to go "all-in" on Solid was pretty heavily influence by
[Netlify hiring the creator of Solid to work on it full-time].
You see, Netlify's biggest competitor is [Vercel][vercel].
Vercel created and maintains [Next.js][next js github].
And I figured Netlify wanted Solid to be their Next.js.
Therefore, I thought there would be no better place to host a SolidStart site than Netlify.

By default, Netlify tries to get you to use their build system.
Using Netlify's build system makes it very hard to do atomic deploys.
Netlify would still publish the frontend even if the backend pipeline failed.
Very bad!
This lead me to move over to building the frontend in the same CI/CD environment as the backend
and then just uploading the latest version to Netlify with their CLI.

Bencher managed to stay under the Netlify free tier for quite some time.
With Bencher's increasing popularity though,
we have started to exceed some of the free tier limits.
I have considered moving the Astro site over to [`sst` on AWS][sst aws astro].
However, the cost savings haven't seemed worth the effort at this point.

> | Technology | Verdict |
> | :--------: | :-----: |
> | Netlify Builds |    ❌    |
> | Netlify Deploys |    ✅    |

[dev to netlify]: https://dev.to/ryansolid/when-netlify-asks-you-to-full-time-oss-you-say-yes-5ccf
[vercel]: https://vercel.com/
[next js github]: https://github.com/vercel/next.js
[sst aws astro]: https://sst.dev/docs/component/aws/astro/

## Backend

### Backend HTTP Framework

When deciding on a backend Rust HTTP framework,
one of my highest considerations was built-in [OpenAPI spec][openapi spec] support.
For the same reasons that I invested in setting up Typeshare and WASM on the frontend,
I wanted the ability to auto-generate both API docs and clients from that spec.
It was important to me that this functionality was built-in and not a 3rd party add-on.
For the automation to actually be worth it, it has to work pretty close to 100% of the time.
This means the maintenance and compatibility burden needs to be on the core framework engineers themselves.
Otherwise, you will inevitably find yourself in edge case hell.

Another key consideration was the risk of abandonment.
There are several once promising Rust HTTP frameworks that now sit all but abandoned.
The only framework that I found that had built-in OpenAPI spec support
that I was willing to bet on was [Dropshot][dropshot github].
Dropshot was created and is still maintained by [Oxide Computer][oxide computer].

I've only had one major issue with Dropshot thus far.
When an error is generated by the API server, it causes a CORS failure on the frontend due to missing response headers.
This means that the web frontend can't display very helpful error messages to users.
Instead of working on upstreaming a fix, I put my efforts towards making Bencher easier and more intuitive to use.
But it turns out the solution was [less than 100 lines of code][dropshot github issue 1193].

As an aside, [the `axum` framework][axum github] had not yet been released when I started working on Bencher.
If it had been around at the time, I may have tried to pair it with one of the many 3rd party OpenAPI add-ons,
despite my better judgment.
Lucky for me, `axum` wasn't yet there to tempt me.

> | Technology | Verdict |
> | :--------: | :-----: |
> | Dropshot   |    ✅    |

[openapi spec]: https://swagger.io/specification/
[dropshot github]: https://github.com/oxidecomputer/dropshot
[oxide computer]: https://oxide.computer/
[dropshot github issue 1193]: https://github.com/oxidecomputer/dropshot/pull/1193
[axum github]: https://github.com/tokio-rs/axum

### Backend Database Framework

The closer to the database I get, the more strongly typed I want things.
It's okay to play a little fast and loose on the frontend.
If I mess up, everything will be right as rain with the next push to production.
If I corrupt the database though, it's much more of an ordeal to set right.
With that in mind, I chose to use [Diesel][diesel github].

Diesel is a strongly typed object relational mapper (ORM) and query builder for Rust.
It checks all database interactions at compile time, preventing runtime errors.
This compile time checking also makes Diesel a zero-cost abstraction over SQL.
Other than a small bug on my end when making thing [1200x faster with performance tuning][engineering sqlite],
I have had no runtime SQL errors when working with Diesel.

> 🐰 Fun Fact: [Diesel uses Bencher][case study diesel] for continuous benchmarking!

[diesel github]: https://github.com/diesel-rs/diesel
[case study diesel]: /learn/case-study/diesel/
[engineering sqlite]: /learn/engineering/sqlite-performance-tuning/

