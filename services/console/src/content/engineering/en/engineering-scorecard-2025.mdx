---
title: "Engineering Scorecard 2025"
description: "A retrospective look at how Bencher has spent its innovation tokens"
heading: "Engineering Scorecard: 2025 Edition"
published: "2025-01-25T16:30:00Z"
modified: "2025-01-25T16:30:00Z"
sortOrder: -2025.0125
draft: true
---

When developing a new technology, like [Bencher][bencher],
there is a fundamental tension between wanting to [choose boring technology][choose boring technology]
and [beating the averages][beating the averages].
In the moment, it can be difficult to tell exactly where one stands in this tug-of-war.
Every three years, the Rust programming language comes out with a new [Rust edition][rust editions].
I think this is a nice cadence. It's long enough for real progress to be made.
Yet, short enough not to drift too far afield.
With Bencher turning 3 years old this spring,
I thought it would be a great time to stop and reflect on all the engineering decisions that got us here.

In this post, I'm going to review where Bencher has spent its "innovation tokens" over the past three years.
I'll start at the frontend of the [Bencher architecture][architecture] and move all the way down the stack.
At each stop along with way, I'll discuss how we got here and rate how each engineering decision panned out.

[bencher]: https://bencher.dev
[choose boring technology]: https://mcfunley.com/choose-boring-technology
[beating the averages]: https://paulgraham.com/avg.html
[rust editions]: https://doc.rust-lang.org/edition-guide/editions/
[architecture]: /docs/reference/architecture/

## Frontend

As a recovering C++ developer, I'm a pretty big fan of Rust.
If I had my druthers, I would have been able to write Bencher in full-stack Rust.
Dig back into the deep recesses of the [Bencher repo][bencher github],
you'll see me trying to do exactly that.
I experimented with [Yew][yew github], [Seed][seed github], and [Sycamore][sycamore github].
While they may work great for some projects,
there was one major sticking point I just couldn't get over: [JavaScript Interoperation][js ffi].

While JS interop is possible from WASM via Rust,
it was not going to be easy.
I knew I wanted Bencher to have highly interactive plots.
This meant using a library like [D3][d3 github],
which meant JS interop.

So if I was going to have to use JavaScript, which framework should I choose?

Going back to those Rust crates I experimented with,
Yew is the Rust analogue to [React Hooks][react hooks].
I'd built and deployed a frontend using React Hooks in the past,
so I knew the most about this framework.
However, I found the React Hooks lifecycle very complicated
and full of gotcha, weird edge cases.

I really liked the core principals of [functional reactive programming][functional reactive programming] (FRP) though.
This lead me to trying out both Elm and its Rust analogue, Seed.
Unfortunately, using Elm suffers from the same issues as using Rust.
Elm requires its own [JavaScript Interop][elm js interop].
I also found [The Elm Architecture][the elm architecture] a bit too restrictive for my liking.

Of all the Rust frameworks that I tried, I liked Sycamore the most.
Sycamore was inspired by [Solid][solid github].
The more that I learned about Solid, the more I liked it.
Unlike React, Solid does not use a [virtual DOM][react virtual dom].
Instead, it compiles to good ole JavaScript.
This makes it much faster, smaller, and easier to work with.
Solid is made up of just a few powerful primitives that allow for fine-grained reactivity.
When something in the UI gets updated, only the code that depends on it will rerun.
Over the past three years, I have found Solid to be a pleasure to work with.

> | Technology | Verdict |
> | :--------: | :-----: |
> |   Rust Frontend    |    ❌    |
> |   SolidJS    |    ✅    |

[bencher github]: https://github.com/bencherdev/bencher
[yew github]: https://github.com/yewstack/yew
[seed github]: https://github.com/seed-rs/seed
[sycamore github]: https://github.com/sycamore-rs/sycamore
[js ffi]: https://rustwasm.github.io/docs/book/reference/js-ffi.html
[d3 github]: https://github.com/d3/d3
[react hooks]: https://react.dev/reference/react/hooks
[functional reactive programming]: https://en.wikipedia.org/wiki/Functional_reactive_programming
[elm js interop]: https://guide.elm-lang.org/interop/
[the elm architecture]: https://guide.elm-lang.org/architecture/
[solid github]: https://github.com/solidjs/solid
[react virtual dom]: https://legacy.reactjs.org/docs/faq-internals.html

Solid itself is "just a library".
In order to build a modern frontend,
I was going to need to use a full fledged web app framework.
Wanting to keep things simple, I put all of my eggs in the Solid basket,
and I initially used [SolidStart][solid start github].
At the time, SolidStart only supported single-page apps (SPAs).

An SPA was fine for getting going.
Eventually though, I needed to start caring about things like SEO.
I was beginning to write a lot more [Bencher documentation][bencher docs].
I was also planning [the Learn section][bencher learn] of the site.
This meant that I needed both client-side rendering (CSR)
and static site generation (SSG).
SolidStart was very young, and I couldn't get it to meet all of my needs.

After learning about [Astro][astro] and trying it out,
I decided to port the entire Bencher frontend from SolidStart over to Astro.
This had a couple of drawbacks.
The most obvious was the effort involved.
Honestly, it wasn't _too_ bad.
Astro has its [islands architecture][astro islands] and
a first class [Solid integration][astro solid].
I was also able to take a lot of the logic that I need from the [Solid Router][solid router],
and it just sort of worked.

The great compromise which is still present today
is that Bencher went from a single-page app to a multi-page app.
Most places you click in the console cause a full page rerender.
Astro had the promise of [view transitions][astro view transitions],
when I first made the switch.
I tried them out, but they were buggy.
I still need to [circle back][github issue 556].

In the mean time, SolidStart seems to have caught up some.
They now support both CSR and SSG.
Though I haven't checked whether they both work on the same site like I need.
Water under the bridge.

> | Technology | Verdict |
> | :--------: | :-----: |
> | SolidStart |    ❌    |
> |   Astro    |    ✅    |

[solid start github]: https://github.com/solidjs/solid-start
[bencher docs]: /docs/
[bencher learn]: /learn/
[astro]: https://astro.build/
[astro islands]: https://docs.astro.build/en/concepts/islands/
[astro solid]: https://docs.astro.build/en/guides/integrations-guide/solid-js/
[solid router]: https://github.com/solidjs/solid-router
[astro view transitions]: https://docs.astro.build/en/guides/view-transitions/
[github issue 556]: https://github.com/bencherdev/bencher/issues/556

Astro has [built-in TypeScript support][astro typescript].
In the transition from SolidStart to Astro, I also started the transition form JavaScript to TypeScript.
Bencher's TypeScript config is set to Astro's `strictest` setting.
However, Astro does not perform type checking during builds.
As of writing, Bencher still has `604` type errors.
These type errors are used more like hints when editing code,
but they don't block the build ([yet][github issue 557]).

I also added [Typeshare][typeshare github] to sync Bencher's Rust data types with the TypeScript frontend.
This has been incredibly helpful for developing the Bencher Console.
Further, all the field validators for things like usernames, emails, etc
are shared between the Rust code and the TypeScript frontend via WASM.
It's been a bit of a hassle to get WASM working in both SolidStart and Astro.
The largest class of error that I've seen in the frontend has been places where a WASM function is called
but the WASM module hasn't loaded yet.
I've figured out how to fix it, but I'll still sometimes forget and it crops up again.

Having both the shared types and validators auto-generated from the Rust code
has made interfacing with the frontend much easier.
They both get checked in CI, so they are never out of sync.
All I have to do is make sure the HTTP requests are well formed,
and it all just works.

> | Technology | Verdict |
> | :--------: | :-----: |
> | JavaScript |    ❌    |
> | TypeScript |    ✅    |
> | Typeshare  |    ✅    |
> |   WASM     |    ✅    |

[astro typescript]: https://docs.astro.build/en/guides/typescript/
[github issue 557]: https://github.com/bencherdev/bencher/issues/557
[typeshare github]: https://github.com/1Password/typeshare

## Backend

