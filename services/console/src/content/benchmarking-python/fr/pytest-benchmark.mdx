---
title: "pytest-benchmark"
description: "Un guide √©tape par √©tape sur la fa√ßon d'√©valuer les performances du code Python avec pytest-benchmark"
heading: "Comment √©valuer les performances du code Python avec pytest-benchmark"
published: "2024-10-09T16:30:00Z"
modified: "2024-11-03T08:45:00Z"
sortOrder: 1
---

import Benchmarking from "../../../chunks/benchmarking/fr/benchmarking.mdx";
import FizzBuzzRules from "../../../chunks/benchmarking/fr/fizz-buzz-rules.mdx";
import FizzBuzzPython from "../../../chunks/benchmarking-python/fr/fizz-buzz-python.mdx";
import StepByStepPython from "../../../chunks/benchmarking-python/fr/step-by-step-python.mdx";
import MicroVsMacro from "../../../chunks/benchmarking/fr/micro-vs-macro.mdx";
import BenchmarkingPython from "../../../chunks/benchmarking-python/fr/benchmarking-python.mdx";
import FizzBuzzRefactor from "../../../chunks/benchmarking-python/pytest-benchmark/fr/fizz-buzz-refactor.mdx";
import BenchmarkingFizzBuzz from "../../../chunks/benchmarking-python/pytest-benchmark/fr/benchmarking-fizz-buzz.mdx";
import FizzBuzzFibonacciPython from "../../../chunks/benchmarking-python/fr/fizz-buzz-fibonacci-python.mdx";
import PlayGameCode from "../../../chunks/benchmarking-python/pytest-benchmark/play-game-code.mdx";
import BenchmarkingFizzBuzzFibonacci from "../../../chunks/benchmarking-python/pytest-benchmark/fr/benchmarking-fizz-buzz-fibonacci.mdx";
import FizzBuzzFibonacciOpenPython from "../../../chunks/benchmarking-python/fr/fizz-buzz-fibonacci-open-python.mdx";
import FizzBuzzFibonacciOpenCode from "../../../chunks/benchmarking-python/fizz-buzz-fibonacci-open-code.mdx";
import TheEnd from "../../../chunks/benchmarking/fr/the-end.mdx";
import OnFire from "../../../chunks/benchmarking/fr/on-fire.mdx";
import TestGameOnFireCode from "../../../chunks/benchmarking-python/pytest-benchmark/test-game-on-fire-code.mdx";
import PytestGameOnFireOutputStart from "../../../chunks/benchmarking-python/pytest-benchmark/pytest-game-on-fire-output-start.mdx";
import PytestGameOnFireOutput from "../../../chunks/benchmarking-python/pytest-benchmark/pytest-game-on-fire-output.mdx";
import FizzBuzzFibonacciFix from "../../../chunks/benchmarking-python/pytest-benchmark/fr/fizz-buzz-fibonacci-fix.mdx";
import PytestGameFixOutput from "../../../chunks/benchmarking-python/pytest-benchmark/pytest-game-fix-output.mdx";
import CatchInCi from "../../../chunks/benchmarking/fr/catch-in-ci.mdx";
import CatchInCiOutput from "../../../chunks/benchmarking-python/pytest-benchmark/catch-in-ci-output.mdx";
import CatchInCiPlot from "../../../chunks/benchmarking/fr/catch-in-ci-plot.mdx";
import CatchInCiPlotRustBench from "../../../chunks/benchmarking-rust/catch-in-ci-plot-rust-bench.mdx";
import BencherFooter from "../../../chunks/learn/fr/bencher-footer.mdx";

<Benchmarking />

<FizzBuzzPython />

<StepByStepPython />

<MicroVsMacro />

<BenchmarkingPython />

Les deux sont [support√©s par Bencher](/fr/docs/explanation/adapters/).
Alors, pourquoi choisir `pytest-benchmark` ?
`pytest-benchmark` s'int√®gre parfaitement avec `pytest`,
qui est le standard de facto pour les tests unitaires dans l'√©cosyst√®me Python.
Je vous sugg√®re d'utiliser `pytest-benchmark` pour √©valuer la latence de votre code,
surtout si vous utilisez d√©j√† `pytest`.
En effet, `pytest-benchmark` est excellent pour mesurer le temps d'horloge.

<FizzBuzzRefactor />

<BenchmarkingFizzBuzz />

<FizzBuzzFibonacciPython>
  <PlayGameCode />
</FizzBuzzFibonacciPython>

<BenchmarkingFizzBuzzFibonacci />

<FizzBuzzFibonacciOpenPython>
    <FizzBuzzFibonacciOpenCode />
</FizzBuzzFibonacciOpenPython>

<TheEnd />

<br />

<OnFire />

<TestGameOnFireCode />

- Un micro-benchmark `test_game_100` pour jouer au jeu avec le nombre cent (`100`)
- Un micro-benchmark `test_game_1_000_000` pour jouer au jeu avec le nombre un million (`1_000_000`)

Lorsque je l'ai ex√©cut√©, j'ai obtenu cela :

<PytestGameOnFireOutputStart />

Attendez... attendez...

<PytestGameOnFireOutput />

Quoi ! `15.8470 us` x `1,000` devrait √™tre `15,847.0 us` pas `571,684.6334 us` ü§Ø
M√™me si j'ai obtenu ma fonction de s√©quence de Fibonacci correctement d'un point de vue fonctionnel, je dois avoir un probl√®me de performance quelque part.

<FizzBuzzFibonacciFix />

Maintenant, relan√ßons ces benchmarks et voyons ce que nous obtenons :

<PytestGameFixOutput />

Oh, wow ! Notre benchmark `test_game` est de retour √† peu pr√®s au m√™me niveau que l'original FizzBuzz.
J'aimerais me souvenir exactement de quel score il s'agissait. Cela fait trois semaines cependant.
Mon historique de terminal ne remonte pas aussi loin.
Et `pytest-benchmark` ne stocke ses r√©sultats que lorsque nous le lui demandons.
Mais je pense que c'est proche !

Le benchmark `test_game_100` a chut√© de pr√®s de 50x √† `322.0815 ns`.
Et le benchmark `test_game_1_000_000` a chut√© de plus de 500,000x ! `571,684,633.4 ns` √† `753.1445 ns` !

> üê∞ Eh bien, au moins, nous avons d√©tect√© ce probl√®me de performance avant qu'il n'arrive en production... oh, d'accord. Peu importe...

<CatchInCi />

<CatchInCiOutput />

<CatchInCiPlot />

<CatchInCiPlotRustBench title="Comment √©valuer les performances de Python avec pytest-benchmark" />

<BencherFooter />