---
title: "Iai"
description: "Un guide √©tape par √©tape sur comment faire des tests de performance sur du code Rust avec Iai"
heading: "Comment tester la performance du code Rust avec Iai"
published: "2024-02-13T06:50:00Z"
sortOrder: 3
---

import Benchmarking from "../../../chunks/benchmarking/fr/benchmarking.mdx";
import FizzBuzzRules from "../../../chunks/benchmarking/fr/fizz-buzz-rules.mdx";
import FizzBuzzRust from "../../../chunks/rust/fr/fizz-buzz-rust.mdx";
import StepByStepRust from "../../../chunks/rust/fr/step-by-step-rust.mdx";
import MicroVsMacro from "../../../chunks/benchmarking/fr/micro-vs-macro.mdx";
import BenchmarkingRust from "../../../chunks/rust/fr/benchmarking-rust.mdx";
import FizzBuzzRefactor from "../../../chunks/rust/criterion/fr/fizz-buzz-refactor.mdx";
import GameBenchesTree from "../../../chunks/rust/criterion/game-benches-tree.mdx";
import FizzBuzzRefactorBenchesCode from "../../../chunks/rust/iai/fizz-buzz-refactor-benches-code.mdx";
import GameCargoToml from "../../../chunks/rust/iai/game-cargo-toml.mdx";
import BenchPlayGameOutput from "../../../chunks/rust/iai/bench-play-game-output.mdx";
import FizzBuzzFibonacciRust from "../../../chunks/rust/fr/fizz-buzz-fibonacci-rust.mdx";
import PlayGameRustCode from "../../../chunks/rust/criterion/play-game-rust-code.mdx";
import BenchPlayGameFibonacciOutput from "../../../chunks/rust/iai/bench-play-game-fibonacci-output.mdx";
import FizzBuzzFibonacciOpenRust from "../../../chunks/rust/fr/fizz-buzz-fibonacci-open-rust.mdx";
import FizzBuzzFibonacciOpenRustCode from "../../../chunks/rust/criterion/fizz-buzz-fibonacci-open-rust-code.mdx";
import TheEnd from "../../../chunks/benchmarking/fr/the-end.mdx";
import OnFire from "../../../chunks/benchmarking/fr/on-fire.mdx";
import BenchPlayGameOnFireCode from "../../../chunks/rust/iai/bench-play-game-on-fire-code.mdx";
import BenchPlayGameOnFireOutputStart from "../../../chunks/rust/iai/bench-play-game-on-fire-output-start.mdx";
import BenchPlayGameOnFireOutput from "../../../chunks/rust/iai/bench-play-game-on-fire-output.mdx";
import FizzBuzzFibonacciFixRust from "../../../chunks/rust/fr/fizz-buzz-fibonacci-fix-rust.mdx";
import BenchPlayGameFixOutput from "../../../chunks/rust/iai/bench-play-game-fix-output.mdx";
import CatchInCi from "../../../chunks/benchmarking/fr/catch-in-ci.mdx";
import CatchInCiOutput from "../../../chunks/rust/iai/catch-in-ci-output.mdx";
import CatchInCiPlot from "../../../chunks/benchmarking/fr/catch-in-ci-plot.mdx";
import CatchInCiPlotRustBench from "../../../chunks/rust/catch-in-ci-plot-rust-bench.mdx";
import BencherFooter from "../../../chunks/learn/fr/bencher-footer.mdx";

<Benchmarking />

<FizzBuzzRust />

<StepByStepRust />

<MicroVsMacro />

<BenchmarkingRust />

Les trois sont [support√©s par Bencher](/fr/docs/explanation/adapters/). Alors pourquoi choisir Iai ?
Iai utilise des compteurs d'instructions plut√¥t que le temps d'horloge mural.
Cela le rend id√©al pour les [benchmark continus](/fr/docs/explanation/continuous-benchmarking/), c'est-√†-dire les benchmarks en CI.
Je sugg√©rerais d'utiliser Iai pour le benchmarking continu, surtout si vous utilisez des runners partag√©s.
Il est important de comprendre qu'Iai ne mesure qu'une approximation de ce qui vous importe vraiment.
Passer de 1 000 instructions √† 2 000 instructions double-t-il la latence de votre application ?
Peut-√™tre ou peut-√™tre pas.
Pour cette raison, il peut √™tre utile de faire √©galement des benchmarks bas√©s sur le temps d'horloge mural en parall√®le avec les benchmarks bas√©s sur les compteurs d'instructions.

> üê∞ Iai n'a pas √©t√© mis √† jour [depuis plus de 3 ans](https://github.com/bheisler/iai/commits/main/). Vous devriez donc envisager [d'utiliser Iai-Callgrind](/fr/docs/explanation/adapters/#-rust-iai-callgrind) √† la place.

## Installer Valgrind

Iai utilise un outil appel√© [Valgrind](https://valgrind.org/) pour collecter les compteurs d'instructions.
Valgrind supporte Linux, Solaris, FreeBSD, et MacOS.
Cependant, le support de MacOS est limit√© aux processeurs x86_64 car les [processeurs arm64 (M1, M2, etc) ne sont pas encore support√©s](https://github.com/LouisBrunner/valgrind-macos/issues/56).

Sur Debian, ex√©cutez : `sudo apt-get install valgrind`

Sur MacOS (seulement les puces x86_64/Intel): `brew install valgrind`

<FizzBuzzRefactor />

## Tester la performance de FizzBuzz

Pour tester notre code, nous devons cr√©er un dossier `benches` et ajouter un fichier pour contenir nos benchmarks, `play_game.rs`:

<GameBenchesTree />

Ajoutez le code suivant √† l'int√©rieur de `play_game.rs` :

<FizzBuzzRefactorBenchesCode />

- Importez la fonction `play_game` de notre crate `game`.
- Cr√©ez une fonction appel√©e `bench_play_game`.
- Ex√©cutez notre macro-benchmark √† l'int√©rieur d'une "bo√Æte noire" pour que le compilateur n'optimise pas notre code.
- It√©rerez de `1` √† `100` inclusivement.
- Pour chaque nombre, appelez `play_game`, avec `print` r√©gl√© sur `false`.

Maintenant, nous devons configurer la crate `game` pour ex√©cuter nos benchmarks.

Ajoutez ce qui suit au _bas_ de votre fichier `Cargo.toml`:

<GameCargoToml />

- `iai`: Ajoutez `iai` comme un d√©pendance de d√©veloppement, puisque nous l'utilisons que pour les tests de performance.
- `bench`: Enregistrez `play_game` comme un benchmark et r√©glez `harness` √† `false`, puisque nous utiliserons Iai comme notre harnais de benchmarking.

Maintenant, nous sommes pr√™ts √† tester la performance de notre code, ex√©cutez `cargo bench` :

<BenchPlayGameOutput />

> üê∞ Laissez tourner la betterave ! Nous avons nos premi√®res m√©triques de benchmark !

Enfin, nous pouvons reposer nos t√™tes fatigu√©es de d√©veloppeurs ...
Juste une blague, nos utilisateurs veulent une nouvelle fonctionnalit√© !

<FizzBuzzFibonacciRust>
  <PlayGameRustCode />
</FizzBuzzFibonacciRust>

## Tester la performance de FizzBuzzFibonacci

Maintenant, nous pouvons relancer notre benchmark :

<BenchPlayGameFibonacciOutput />

Oh, g√©nial ! Iai nous dit que la diff√©rence entre les cycles estim√©s de nos jeux FizzBuzz et FizzBuzzFibonacci est de `+522.6091%`.
Vos chiffres seront un peu diff√©rents des miens.
Cependant, la diff√©rence entre les deux jeux est probablement dans la plage des `5x`.
Cela me semble bien ! Surtout pour ajouter une fonctionnalit√© aussi sophistiqu√©e que _Fibonacci_ √† notre jeu.
Les enfants vont adorer !

<FizzBuzzFibonacciOpenRust>
  <FizzBuzzFibonacciOpenRustCode />
</FizzBuzzFibonacciOpenRust>

<TheEnd />

<br />

<OnFire />

<BenchPlayGameOnFireCode />

- Un micro-benchmark `bench_play_game_100` pour jouer au jeu avec le nombre cent (`100`)
- Un micro-benchmark `bench_play_game_1_000_000` pour jouer au jeu avec le nombre un million (`1_000_000`)

Quand je l'ai ex√©cut√©, j'ai obtenu ceci :

<BenchPlayGameOnFireOutputStart />

Attendez-le... attendez-le...

<BenchPlayGameOnFireOutput />

Quoi! `6,685 cycles estim√©s` x `1,000` devrait √™tre `6,685,000 cycles estim√©s` et non pas `155,109,206 cycles estim√©s` ü§Ø
M√™me si j'ai bien programm√© ma fonction de la s√©quence de Fibonacci, je dois avoir un bug de performance quelque part.

<FizzBuzzFibonacciFixRust />

Maintenant, r√©ex√©cutons ces benchmarks pour voir comment nous avons r√©agi :

<BenchPlayGameFixOutput />

Oh, wouah ! Notre benchmark `bench_play_game` est revenu √† peu pr√®s au m√™me niveau qu'il √©tait pour le FizzBuzz original.
J'aurais aim√© me souvenir exactement de ce score. √áa fait trois semaines cependant.
Mon historique de terminal ne remonte pas aussi loin.
Et Iai ne compare qu'avec le r√©sultat le plus r√©cent.
Mais je pense que c'est proche !

Le benchmark `bench_play_game_100` a diminu√© pr√®s de 10 fois, `-87.22513%`.
Et le benchmark `bench_play_game_1_000_000` a diminu√© de plus de 10,000 fois ! De `155,109,206 cycles estim√©s` √† `950 cycles` estim√©s !
C'est `-99.99939%` !

> üê∞ Heureusement, nous avons rep√©r√© ce bug de performance avant qu'il n'atteigne la production... ah, non. Oublie √ßa...

<CatchInCi />

<CatchInCiOutput />

<CatchInCiPlot />

<CatchInCiPlotRustBench title="Comment faire des tests de performance sur Rust avec Iai" />

<BencherFooter />
